/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Main.java to edit this template
 */
package dfs_bfs;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
import java.util.Set;

/**
 *
 * @author thierno
 */
public class DFS_BFS {

    /**
     * @param args the command line arguments
     */
    private static Scanner scanner = new Scanner(System.in);
    private static List<List<Integer>> graph = null;
    
    public static void main(String[] args) {
        System.out.println("=== SIMULATEUR D'ALGORITHMES DE PARCOURS DE GRAPHE ===");
        
        while (true) {
            afficherMenuPrincipal();
            int choix = saisirEntier("Votre choix: ");
            
            switch (choix) {
                case 1:
                    menuDFS();
                    break;
                case 2:
                    menuBFS();
                    break;
                case 3:
                    System.out.println("Au revoir !");
                    return;
                default:
                    System.out.println("‚ùå Choix invalide, veuillez r√©essayer.");
            }
        }
    }
    
    private static void afficherMenuPrincipal() {
        System.out.println("\n" + "=".repeat(40));
        System.out.println("         MENU PRINCIPAL");
        System.out.println("=".repeat(40));
        System.out.println("1. üîç DFS (Depth-First Search)");
        System.out.println("2. üìä BFS (Breadth-First Search)");
        System.out.println("3. üö™ Quitter");
        System.out.println("=".repeat(40));
        
        if (graph != null) {
            System.out.println("Graphe actuel: " + graph.size() + " sommets");
        }
    }
    
    private static void menuDFS() {
        while (true) {
            afficherMenuDFS();
            int choix = saisirEntier("Votre choix: ");
            
            switch (choix) {
                case 1:
                    creerGraphe();
                    break;
                case 2:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        executerDFSRecursif();
                    }
                    break;
                case 3:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        executerDFSIteratif();
                    }
                    break;
                case 4:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        executerDFSComplet();
                    }
                    break;
                case 5:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        verifierCycle();
                    }
                    break;
                case 6:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        executerTriTopologique();
                    }
                    break;
                case 7:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        executerComposantesConnexes();
                    }
                    break;
                case 8:
                    afficherGraphe();
                    break;
                case 0:
                    return;
                default:
                    System.out.println("‚ùå Choix invalide.");
            }
        }
    }
    
    private static void menuBFS() {
        while (true) {
            afficherMenuBFS();
            int choix = saisirEntier("Votre choix: ");
            
            switch (choix) {
                case 1:
                    creerGraphe();
                    break;
                case 2:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        executerBFS();
                    }
                    break;
                case 3:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        executerBFSNiveaux();
                    }
                    break;
                case 4:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        executerBFSAvecDistances();
                    }
                    break;
                case 5:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        trouverPlusCourtChemin();
                    }
                    break;
                case 6:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        verifierAccessibilite();
                    }
                    break;
                case 7:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        trouverSommetsAccessibles();
                    }
                    break;
                case 8:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        executerBFSComplet();
                    }
                    break;
                case 9:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        compterComposantes();
                    }
                    break;
                case 10:
                    if (graph == null) {
                        System.out.println("‚ùå Aucun graphe d√©fini. Cr√©ez d'abord un graphe.");
                    } else {
                        trouverCheminsLongueurK();
                    }
                    break;
                case 11:
                    afficherGraphe();
                    break;
                case 0:
                    return;
                default:
                    System.out.println("‚ùå Choix invalide.");
            }
        }
    }
    
    private static void afficherMenuDFS() {
        System.out.println("\n" + "-".repeat(40));
        System.out.println("         MENU DFS");
        System.out.println("-".repeat(40));
        System.out.println("1. ‚ûï Cr√©er un nouveau graphe");
        System.out.println("2. üîÑ DFS R√©cursif");
        System.out.println("3. üìö DFS It√©ratif");
        System.out.println("4. üåê DFS Complet");
        System.out.println("5. üîÅ D√©tecter les cycles");
        System.out.println("6. üìã Tri topologique");
        System.out.println("7. üß© Composantes fortement connexes");
        System.out.println("8. üëÅÔ∏è  Afficher le graphe");
        System.out.println("0. üîô Retour");
        System.out.println("-".repeat(40));
        
        if (graph != null) {
            System.out.println("Graphe actuel: " + graph.size() + " sommets");
        } else {
            System.out.println("‚ö†Ô∏è  Aucun graphe d√©fini");
        }
    }
    
    private static void afficherMenuBFS() {
        System.out.println("\n" + "-".repeat(40));
        System.out.println("         MENU BFS");
        System.out.println("-".repeat(40));
        System.out.println("1. ‚ûï Cr√©er un nouveau graphe");
        System.out.println("2. üîÑ BFS basique");
        System.out.println("3. üìà BFS niveau par niveau");
        System.out.println("4. üìè BFS avec distances");
        System.out.println("5. üõ§Ô∏è  Plus court chemin");
        System.out.println("6. ‚úÖ V√©rifier accessibilit√©");
        System.out.println("7. üéØ Sommets accessibles");
        System.out.println("8. üåê BFS complet");
        System.out.println("9. üî¢ Compter composantes");
        System.out.println("10. üìê Chemins de longueur K");
        System.out.println("11. üëÅÔ∏è  Afficher le graphe");
        System.out.println("0. üîô Retour");
        System.out.println("-".repeat(40));
        
        if (graph != null) {
            System.out.println("Graphe actuel: " + graph.size() + " sommets");
        } else {
            System.out.println("‚ö†Ô∏è  Aucun graphe d√©fini");
        }
    }
    
    private static void menuGraphe() {
        // Cette m√©thode n'est plus n√©cessaire avec la nouvelle structure
    }
    
    private static void creerGraphe() {
        System.out.println("\n=== CR√âATION DU GRAPHE ===");
        
        int nombreSommets = saisirEntier("Nombre de sommets: ");
        while (nombreSommets <= 0) {
            System.out.println("‚ùå Le nombre doit √™tre positif.");
            nombreSommets = saisirEntier("Nombre de sommets: ");
        }
        
        graph = DFS.createGraph(nombreSommets);
        System.out.println("‚úÖ Graphe cr√©√© avec " + nombreSommets + " sommets (0 √† " + (nombreSommets-1) + ")");
        
        ajouterAretes();
    }
    
    private static void modifierGraphe() {
        // Cette m√©thode n'est plus n√©cessaire avec la nouvelle structure
    }
    
    private static void ajouterAretes() {
        System.out.println("\n=== AJOUT DES AR√äTES ===");
        System.out.println("Sommets disponibles: 0 √† " + (graph.size()-1));
        
        while (true) {
            System.out.println("\nVoulez-vous ajouter une ar√™te ?");
            System.out.println("1. ‚úÖ Oui");
            System.out.println("2. ‚ùå Non, terminer");
            
            int continuer = saisirEntier("Votre choix: ");
            if (continuer != 1) break;
            
            int source = saisirSommetValide("Sommet source: ");
            int destination = saisirSommetValide("Sommet destination: ");
            
            if (graph.get(source).contains(destination)) {
                System.out.println("‚ö†Ô∏è  L'ar√™te " + source + "‚Üí" + destination + " existe d√©j√†.");
            } else {
                DFS.addEdge(graph, source, destination);
                System.out.println("‚úÖ Ar√™te ajout√©e: " + source + " ‚Üí " + destination);
            }
        }
        
        System.out.println("‚úÖ Configuration des ar√™tes termin√©e.");
    }
    
    private static void afficherGraphe() {
        if (graph == null) {
            System.out.println("‚ùå Aucun graphe d√©fini.");
            return;
        }
        
        System.out.println("\n=== GRAPHE ACTUEL ===");
        DFS.printGraph(graph);
        
        int totalAretes = 0;
        for (List<Integer> adjacents : graph) {
            totalAretes += adjacents.size();
        }
        System.out.println("R√©sum√©: " + graph.size() + " sommets, " + totalAretes + " ar√™tes");
    }
    
    // M√©thodes d'ex√©cution DFS
    private static void executerDFSRecursif() {
        int sommet = saisirSommetValide("Sommet de d√©part: ");
        System.out.println("\nüîÑ DFS R√©cursif:");
        DFS.dfsRecursive(graph, sommet);
        pauseClavier();
    }
    
    private static void executerDFSIteratif() {
        int sommet = saisirSommetValide("Sommet de d√©part: ");
        System.out.println("\nüìö DFS It√©ratif:");
        DFS.dfsIterative(graph, sommet);
        pauseClavier();
    }
    
    private static void executerDFSComplet() {
        System.out.println("\nüåê DFS Complet:");
        DFS.dfsComplete(graph);
        pauseClavier();
    }
    
    private static void verifierCycle() {
        System.out.println("\nüîÅ D√©tection de cycles:");
        boolean cycle = DFS.hasCycle(graph);
        if (cycle) {
            System.out.println("üî¥ Le graphe contient un cycle.");
        } else {
            System.out.println("üü¢ Le graphe ne contient pas de cycle.");
        }
        pauseClavier();
    }
    
    private static void executerTriTopologique() {
        System.out.println("\nüìã Tri topologique:");
        if (DFS.hasCycle(graph)) {
            System.out.println("‚ùå Impossible: le graphe contient un cycle.");
        } else {
            List<Integer> result = DFS.topologicalSort(graph);
            System.out.println("‚úÖ Ordre topologique: " + result);
        }
        pauseClavier();
    }
    
    private static void executerComposantesConnexes() {
        System.out.println("\nüß© Composantes fortement connexes:");
        DFS.stronglyConnectedComponents(graph);
        pauseClavier();
    }
    
    // M√©thodes d'ex√©cution BFS
    private static void executerBFS() {
        int sommet = saisirSommetValide("Sommet de d√©part: ");
        System.out.println("\nüîÑ BFS:");
        BFS.bfs(graph, sommet);
        pauseClavier();
    }
    
    private static void executerBFSNiveaux() {
        int sommet = saisirSommetValide("Sommet de d√©part: ");
        System.out.println("\nüìà BFS niveau par niveau:");
        BFS.bfsLevelOrder(graph, sommet);
        pauseClavier();
    }
    
    private static void executerBFSAvecDistances() {
        int sommet = saisirSommetValide("Sommet de d√©part: ");
        System.out.println("\nüìè Calcul des distances:");
        BFS.bfsWithDistances(graph, sommet);
        pauseClavier();
    }
    
    private static void trouverPlusCourtChemin() {
        int source = saisirSommetValide("Sommet source: ");
        int destination = saisirSommetValide("Sommet destination: ");
        
        System.out.println("\nüõ§Ô∏è  Plus court chemin:");
        List<Integer> path = BFS.shortestPath(graph, source, destination);
        
        if (path.isEmpty()) {
            System.out.println("‚ùå Aucun chemin trouv√© entre " + source + " et " + destination);
        } else {
            System.out.println("‚úÖ Chemin: " + path);
            System.out.println("üìè Longueur: " + (path.size() - 1) + " ar√™te(s)");
        }
        pauseClavier();
    }
    
    private static void verifierAccessibilite() {
        int source = saisirSommetValide("Sommet source: ");
        int destination = saisirSommetValide("Sommet destination: ");
        
        System.out.println("\n‚úÖ V√©rification d'accessibilit√©:");
        boolean accessible = BFS.isReachable(graph, source, destination);
        
        if (accessible) {
            System.out.println("üü¢ " + destination + " est accessible depuis " + source);
        } else {
            System.out.println("üî¥ " + destination + " n'est pas accessible depuis " + source);
        }
        pauseClavier();
    }
    
    private static void trouverSommetsAccessibles() {
        int sommet = saisirSommetValide("Sommet de d√©part: ");
        
        System.out.println("\nüéØ Sommets accessibles:");
        Set<Integer> accessibles = BFS.findReachableVertices(graph, sommet);
        
        List<Integer> sorted = new ArrayList<>(accessibles);
        Collections.sort(sorted);
        System.out.println("‚úÖ Accessibles: " + sorted);
        System.out.println("üìä Total: " + accessibles.size() + " sommet(s)");
        pauseClavier();
    }
    
    private static void executerBFSComplet() {
        System.out.println("\nüåê BFS Complet:");
        BFS.bfsComplete(graph);
        pauseClavier();
    }
    
    private static void compterComposantes() {
        System.out.println("\nüî¢ Composantes connexes:");
        int count = BFS.countConnectedComponents(graph);
        System.out.println("‚úÖ Nombre de composantes: " + count);
        pauseClavier();
    }
    
    private static void trouverCheminsLongueurK() {
        int sommet = saisirSommetValide("Sommet de d√©part: ");
        int k = saisirEntierPositif("Longueur K: ");
        
        System.out.println("\nüìê Chemins de longueur " + k + ":");
        List<List<Integer>> paths = BFS.findPathsOfLengthK(graph, sommet, k);
        
        if (paths.isEmpty()) {
            System.out.println("‚ùå Aucun chemin de longueur " + k + " trouv√©.");
        } else {
            System.out.println("‚úÖ " + paths.size() + " chemin(s) trouv√©(s):");
            int maxAffichage = 10;
            for (int i = 0; i < Math.min(paths.size(), maxAffichage); i++) {
                System.out.println("  " + (i + 1) + ". " + paths.get(i));
            }
            if (paths.size() > maxAffichage) {
                System.out.println("  ... et " + (paths.size() - maxAffichage) + " autres");
            }
        }
        pauseClavier();
    }
    
    // M√©thodes utilitaires
    private static int saisirEntier(String message) {
        while (true) {
            System.out.print(message);
            try {
                return Integer.parseInt(scanner.nextLine().trim());
            } catch (NumberFormatException e) {
                System.out.println("‚ùå Nombre entier requis.");
            }
        }
    }
    
    private static int saisirEntierPositif(String message) {
        while (true) {
            int valeur = saisirEntier(message);
            if (valeur >= 0) {
                return valeur;
            }
            System.out.println("‚ùå Valeur positive requise.");
        }
    }
    
    private static int saisirSommetValide(String message) {
        while (true) {
            int sommet = saisirEntier(message);
            if (sommet >= 0 && sommet < graph.size()) {
                return sommet;
            }
            System.out.println("‚ùå Sommet invalide. Utilisez 0 √† " + (graph.size() - 1));
        }
    }
    
    private static void pauseClavier() {
        System.out.println("\nAppuyez sur ENTR√âE pour continuer...");
        scanner.nextLine();
    }
    
}
